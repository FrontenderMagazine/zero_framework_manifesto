Перестаньте писать Javascript фреймворки.

Javascript фреймворки подобно смерти и налогам; неминуемые и неизбежны. Я 
уверен, что если бы я мог быть мухой на той стене, где каждый раз, когда кто-то
начинает новый веб-проект, то самый первый вопрос, который они бы задали ето, 
какой JS фреймворк мы используем? Вот как укоренилось роль JS фреймворков в 
отрасли сегодня. Но это не тот путь, по которому должно все идти, и на самом 
деле, ето нужно остановить.

> Angular и Backbone и Ember, о мой.

В течение долгого времени [веб-платформы][1], технологичный стек наиболее 
лаконично описывается как HTML+CSS+JS, был, из-за отсутствия лучшего термина,
катастрофичным. Кто может забыть блочную модель IE, или layer тег? Я уверен, 
что у некоторых из вас началось подергивание из-за воспоминаний о старых плохих
временах веб-разработки благодаря словам выше.

Долгое время было намного несоответствия между браузерами и мы, как отрасль, 
должны были писать фреймворки как обои над ними. Проблема в том,
что разногласия даже по фундаментальных вопросах, среди браузеров, например как 
события распространяются или какие теги поддерживаются, так что каждый фреймворк
не только был обоями над дирами, но разработывал свои собственные модели, как 
браузер должен работь. На самом деле их собственные модел*и*, во множественном 
числе, потому что вы должны изобрести модель о том как события распространяются,
модель как взаимодействовать с DOM, и т.д. Много изобретений было сделано. И так 
фреймворки были написаны, каждый как снежинка, тысячи цветков цвели  и дали нам 
что то вроде JQuery и Dojo и MochiKit и Ext JS и AngularJS и Backbone и Ember и 
React. За прошедшие *десять* лет мы наблюдали устойчивый парад JS фреймворков.

Но что-то еще произошло за последние десять лет; браузеры стали лучше.
Их поддержка стандартов улучшилась, и сейчас есть вечнозеленые браузеры:
автоматическое обновление браузеров, каждая версия более способна и стандарто
совместима, чем в прошлом. В новых стандартах, таких как:

*   [HTML Imports][2]
*   [Object.observe][3]
*   [Promises][4]
*   [HTML Templates][5]

Я думаю, пришло время переосмыслить модель JS фреймворков. Нет необходимости
изобретать еще один способ сделать что-то, просто используйте HTML+CSS+JS.

Так почему же мы все еще пишем JS фреймворки? Я думаю, что большая часть сего
инерция, это привычка. Но так ли это плохо, это не так, как фреймворки активно
вредно, не так ли? Но, давайте сначала определим то, что я имею в виду под веб
фреймворком. На самом деле ето градиент кода, который начинается с простого 
фрагмента, например Gist, и потом движется ко все более крупной коллекции кода,
двигаясь вверх к библиотеке, и, наконец, фреймворку:

> gist -> library -> framework 

Фреймворки не только крупные библиотеки, они имеют свои собственные модели для 
того, как взаимодействовать с событиями, с DOM, и т.д. Так почему избегать 
фреймворков?

**Абстракции** Ну, одна из проблем фреймворков, как правило, одина из
их торговых точок, ето то что они абстрагируються от платформы, так что вы 
можете сосредоточиться на создании собственного программного обеспечения. 
Проблема в том, что теперь вам нужно знать две системы, HTML+CSS+JS и фреймворк.
Конечно, если фреймворк был бы идеально абстрагирован от сети как платформы, 
за которую вы никогда не должны выходить, но догадайтесь, что, 
[утечка абстракции][6]. Таким образом, вы должны знать, HTML+CSS+JS, потому что
в какой-то момент ваша программа не будет работать так, как вы ожидаете, и вы 
будете копаться вниз через все слои в фреймворке, что бы понять что не так,
вплоть до HTML+CSS+JS.

> Картографирование айсберга. 

Фреймворк, как айсберг, те 10% плавающей над водой не выглядят опасно, зато 
скрытые 90%, именно то, что в конечном счете ловит вас. На самом деле это даже
более склонны, изучение фреймворка, как картографировать айсберг, для того, чтобы
использовать его вам нужно узнать все о нем, применить усилие картографировать
всей особености, и в конечном счете процесс идет в никуда, потому что
айсберг будет таять в любом случае.

**Виджеты** Другой пункт продажи фреймворков, то что вы можете получить доступ к
библиотека виджетов. Но на самом деле, вы не должны принимать фреймворки, чтобы 
получить доступ к виджетам, все они должны быть ортогональны и независимы. 
Хорошим примером этого на сегодня есть [CodeMirror][7], редактор подсветки 
синтаксиса кода, построенного на JavaScript. Вы можете использовать его в везде,
никаких фреймворков не требуется.

Ето также утеряные усилия в создании виджетов для фреймворка. Помните все те 
виджеты которые вы написали для MochiKit? Да, как много хорошего они делают для 
вас сейчас когда вы мигрировали на Ember, или Angular?

**Привязка данных** Честно говоря, я никогда не нуждался в этом, но если вам 
нужно, тогда это должно быть в виде библиотеки, а не фреймворка.

Долгосрочная проблема с фреймворками, что они в конечном итоге заканчивают как 
силос, они сегментят пейзаж, виджет построенный для фреймворка А не работает в Б.
Это потеряные усилия.

Итак, как выглядит пост-фреймворковый мир?

> HTML+CSS+JS есть мой фреймворк. 

Основная идея в том, что фреймворки не нужны, используйте возможности уже 
встроеные в HTML+CSS+JS для создания ваших виджетов. Разбейте монолиты на куски
ортогональных компонентов, которые могут быть смешаны в любом сочетании. 
Финальный кусок будет объединять и включать весь етот град под одной парасолькой
[Web Components][8]

HTML импорт, HTML шаблоны, настраиваемые элементы, и Shadow DOM являются 
включающими технологиями, которые должны позволить нам разрезать путы от 
фреймворков, позволяющих создание многоразовых элементов и функциональности. Для
наглядного представления смотрите ети статьи и библиотеки:

*   [HTML Imports][9]
*   [Polymer][10]
*   [X-Tag][11]
*   [Bosonic][12]

Так, мы все создадим [<x-flipbox>][13], объявим о победе, и вернемся домой?

Нет, не совсем, первое, что вам нужно для работы с веб-компонентами является
мультизаполнение (от пер. polyfill) для этой функциональности, такое как X-Tag и
Polymer. Потребность в етом будет уменьшаться с течением времени, как браузеры 
конкретизируют свои реализации тех спецификаций.

Момент, который следует подчеркнуть, что это мультизаполнение не фреймворки, 
которые предоставляют свои собственные модели для разработки в сети, они 
включают HTML5 модель. Но это на самом деле не только необходимость, есть еще и 
небольшие пробелы в платформе, где один браузер отклоняется в небольшом от
действующих стандартов, и это то, что мы должны мультизаполнить. В [MDN][14], 
кажется, есть много необходимого кода, как в документации часто содержится
[короткое между функционное мультизаполнение][15].

Так одна огромная HTML5 Polyfill библиотека будет уже хорошо, но еще лучше было 
бы то, что я callhtml-5-polyfill-O-Matic, набор инструментов, который позволяет 
мне писать веб-компонент через трясину стандартнов HTML+JS, а затем после 
анализа моего кода, либо через статический анализ или через `Object.observe` во
время выполнения, он произведет точное подмножество полного HTML5 
мультизаполнения для моего проекта.

Этот вид функциональности будет еще более важен, чем когда я начал попытки 
скрестить и соотвести веб-компоненты и библиотеки из нескольких источников, т.е.
<x-foo> от X-Tag и <core-bar> от Polymer, значит ли это, что мне придется
включают обе ети мультизаполнительные библиотеки?
([Оказывается, что ответ нет][16].) И как именно я должен получить эти
спецефические элементы? Оба X-Tag и Brick имеют спецефические пакеты генераторов:

*   [Brick Download][17] 
*   [X-Tag Download][18] 

Если я начну создавать собственные элементы мне нужно будет создавать и свой 
собственный пакет тоже? Я не думаю, что это масштабируемая идея, я считаю, что 
нам нужны идиомы и инструменты что справиться с этим гораздо лучше. Это на самом
деле может означать изменение, того как мы делаем открытый код; 'виджет' не 
проект, поэтому наша работа с этими вещами должна изменится. Конечно, далее 
оставлять код в Git, но вам нужен полный накладной проект на GitHub? Что-то 
более легковесящее, ближе к Gist, чем текущий проект может быть лучше. Как 
свести к минимуму [извержение] [19] всего этого кода в нужной форме для 
использования в моем проекте?
Что-то вроде [Asset Graph][20] может быть хорошим началом для этого.

И так, что нам теперь нужно?

Это то, что мы должны построить в будущем, в котором мы не нуждаемся, в знании 
знать последнею модель новейшого фреймворка, вместо этого мы просто работаем 
напрямую с платформой, потянув в спецефических элементах и библиотеках для 
заполнения конкретных потребностей, и тратить наше время создавая приложение, 
при этом не картографировать айсберги.

## Вопросы и Ответы {#qa}

**Q:** Why do you hate framework authors.

**A:** I don’t hate them. Some of my best friends are framework authors. I
will admit a bit of inspiration from the tongue-in-cheek
[you have ruined javascript][21], but again, no derision intended for framework
authors.

**Q:** You can’t do \__\_|\_ in HTML5, for that you need a framework.

**A:** First, that's not a question. Second, thanks for pointing that out. Now
let's work together to add the capabilities to HTML 5 that allows \__\_|\_ to be
done w/o a framework.

**Q:** But \___| isn't a framework, it's a library!

**A:** Yeah, like I said, it’s a gradient from gist to framework, and you
might draw the lines slightly differently from me. That's OK, this isn't about 
the categorization of any one particular piece of software, it's about moving 
away from frameworks.

**Q:** I've been doing this for years, with \_\_\_| and \\_\_\_| and \\___|.

**A:** Again, that's not a question, but regardless, good for you, you should
be in good shape to help everyone else.

**Q:** So everyone needs to rewrite dropdown menus, tabs, sliders and toggles
themselves?

**A:** Absolutely not, the point is there should be a way to create those
elements in a way that doesn't require buying into one particular framework.

**Q:** Dude, all those HTML Imports are going to kill my sites performance.

**A:** Yes, if you implemented all this stuff naively it would, which is why I
[mentioned the need for tools][22] to compile and crush all the HTML, CSS, and
JS.

**Q:** So I'm not supposed to use *any* libraries? 

**A:** No, that's not what I said, I was very careful to delineate a line
between libraries and frameworks, a library providing an orthogonal piece of 
functionality that can be used with other libraries. Libraries are fine, it's 
the frameworks that demand 100% buyin that I'd like to see us move away from.

**Q:** Но мне нравится привязки данных!

**A:** Много кто ето делает, я только высказываю личные предпочтения. Я не 
говорю, что *вы* не должны использовать связывание данных, но только то, что вам
не нужно, принимать весь фреймворк, чтобы получить привязку данных, есть 
автономные библиотеки для етого.

2014-05-09

 [1]: http://platform.html5.org/
 [2]: http://w3c.github.io/webcomponents/spec/imports/
 [3]: http://wiki.ecmascript.org/doku.php?id=harmony:observe
 [4]: http://www.html5rocks.com/en/tutorials/es6/promises/
 [5]: http://www.w3.org/TR/html5/scripting-1.html#the-template-element
 [6]: http://www.joelonsoftware.com/articles/LeakyAbstractions.html
 [7]: http://codemirror.net/
 [8]: http://www.w3.org/TR/components-intro/
 [9]: http://www.html5rocks.com/en/tutorials/webcomponents/imports/
 [10]: http://www.polymer-project.org/
 [11]: http://www.x-tags.org/
 [12]: http://bosonic.github.io/
 [13]: http://mozbrick.github.io/docs/brick-flipbox.html
 [14]: https://developer.mozilla.org
 [15]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility
 [16]: http://www.polymer-project.org/articles/polymer-xtag-vanilla.html
 [17]: http://mozilla.github.io/brick/download.html
 [18]: http://www.x-tags.org/download
 [19]: https://github.com/Polymer/vulcanize
 [20]: https://github.com/assetgraph/assetgraph-builder
 [21]: http://codeofrob.com/entries/you-have-ruined-javascript.html
 [22]: http://bitworking.org/news/2014/05/zero_framework_manifesto#tools2
