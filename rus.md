# Перестаньте писать Javascript фреймворки

Javascript фреймворки подобно смерти и налогам неминуемы и неизбежны.
Я уверен, что если бы мог подслушать всех, кто начинает веб-проекты, то каждый
раз я услышал бы в качестве первого вопроса «какой JS фреймворк мы используем?»
Вот, как укоренилось роль JS фреймворков в
отрасли сегодня. Но это не тот путь, по которому должно всё идти, и на самом
деле, это нужно остановить.

## Angular и Backbone и Ember, о боже

Долгое время [веб-платформы][1], технологичный стек наиболее
лаконично описываемый как HTML+CSS+JS, был, из-за отсутствия лучшего термина,
катастрофичным. Кто может забыть блочную модель IE, или тег layer? Я уверен,
что у некоторых из вас началось подергивание из-за воспоминаний о старых плохих
временах веб-разработки от одних только этих слов.

Долгое время было много несоответствия между браузерами и мы, как отрасль,
должны были писать фреймворки, чтобы скрыть эти недостатки. Проблема в том,
что разногласия среди браузеров были даже в фундаментальных вопросах, например как
события распространяются или какие теги поддерживаются, так что каждый фреймворк
не только прикрывал дырки, но разработывал свою собственную модель того, как
браузер должен работь. На самом деле их собственные модел*и*, во множественном
числе, потому что вы должны изобрести модель распространения событий,
модель взаимодействия с DOM, и т.д. Много изобретений было сделано.
Фреймворки писались, каждый уникальный как снежинка, они расцвели как тысяча
цветов и дали нам все эти JQuery и Dojo и MochiKit и ExtJS и AngularJS и
Backbone и Ember и React.
За прошедшие *десять* лет мы наблюдали устойчивый парад JS фреймворков.

Но что-то ещё произошло за последние десять лет — браузеры стали лучше.
Их поддержка стандартов улучшилась, и сейчас есть вечнозелёные браузеры:
автоматическое обновление браузеров, и каждой новой версии больше возможностей и
и лучше соответствие стандартам, чем у предыдущих. И с новыми стандартами,
такими как:

*   [Импорты HTML][2]
*   [Object.observe][3]
*   [Promises][4]
*   [Шаблоны HTML][5]

Я думаю, пришло время переосмыслить модель JS фреймворков. Нет необходимости
изобретать ещё один способ сделать что-то, просто используйте HTML+CSS+JS.

Так почему же мы все ещё пишем JS фреймворки? Я думаю, по большей части из-за
инерции, это привычка. Но так ли это плохо, фреймворки же, вроде, не наносят
вреда сами по себе? Что ж, давайте сначала определим то, что я имею в виду под веб
фреймворком. На самом деле есть градиент кода, который начинается с простого
фрагмента, например Gist, и потом движется ко всё более крупной коллекции кода,
двигаясь вверх к библиотеке, и, наконец, фреймворку:

## gist -> билблиотека -> фреймворк

Фреймворки не только крупные библиотеки, они имеют свои собственные модели для
того, как взаимодействовать с событиями, с DOM, и т.д. Так почему избегать
фреймворков?

**Абстракции** Ну, одна из проблем фреймворков, как правило, одина из
их торговых точок, это то что они абстрагируються от платформы, так что вы
можете сосредоточиться на создании собственного программного обеспечения.
Проблема в том, что теперь вам нужно знать две системы, HTML+CSS+JS и фреймворк.
Конечно, если фреймворк был бы идеально абстрагирован от сети как платформы,
за которую вы никогда не должны выходить, но догадайтесь, что,
[утечка абстракции][6]. Таким образом, вы должны знать, HTML+CSS+JS, потому что
в какой-то момент ваша программа не будет работать так, как вы ожидаете, и вы
будете копаться вниз через все слои в фреймворке, что бы понять что не так,
вплоть до HTML+CSS+JS.

# Картографирование айсберга

Фреймворк, как айсберг, те 10% плавающей над водой не выглядят опасно, зато
скрытые 90%, именно то, что в конечном счете ловит вас. На самом деле это даже
более склонны, изучение фреймворка, как картографировать айсберг, для того, чтобы
использовать его вам нужно узнать все о нем, применить усилие картографировать
всей особености, и в конечном счете процесс идет в никуда, потому что
айсберг будет таять в любом случае.

**Виджеты** Другой пункт продажи фреймворков, то что вы можете получить доступ к
библиотека виджэтов. Но на самом деле, вы не должны принимать фреймворки, чтобы
получить доступ к виджетам, все они должны быть ортогональны и независимы.
Хорошим примером этого на сегодня есть [CodeMirror][7], редактор подсветки
синтаксиса кода, построенного на JavaScript. Вы можете использовать его в везде,
никаких фреймворков не требуется.

это также утеряные усилия в создании виджэтов для фреймворка. Помните все те
виджеты которые вы написали для MochiKit? Да, как много хорошего они делают для
вас сейчас когда вы мигрировали на Ember, или Angular?

**Привязка данных** Честно говоря, я никогда не нуждался в этом, но если вам
нужно, тогда это должно быть в виде библиотеки, а не фреймворка.

Долгосрочная проблема с фреймворками, что они в конечном итоге заканчивают как
силос, они сегментят пейзаж, виджет построенный для фреймворка А не работает в Б.
Это потеряные усилия.

Итак, как выглядит пост-фреймворковый мир?

# Мой фреймворк — это HTML+CSS+JS

Основная идея в том, что фреймворки не нужны, используйте возможности уже
встроеные в HTML+CSS+JS для создания ваших виджэтов. Разбейте монолиты на куски
ортогональных компонентов, которые могут быть смешаны в любом сочетании.
Финальный кусок будет объединять и включать весь этот град под одной парасолькой
[Web Components][8]

HTML импорт, HTML шаблоны, настраиваемые элементы, и Shadow DOM являются
включающими технологиями, которые должны позволить нам разрезать путы от
фреймворков, позволяющих создание многоразовых элементов и функциональности. Для
наглядного представления смотрите ети статьи и библиотеки:

*   [Импорты HTML][9]
*   [Polymer][10]
*   [X-Tag][11]
*   [Bosonic][12]

Так, мы все создадим [<x-flipbox>][13], объявим о победе, и вернемся домой?

Нет, не совсем, первое, что вам нужно для работы с веб-компонентами является
мультизаполнение (от пер. polyfill) для этой функциональности, такое как X-Tag и
Polymer. Потребность в этом будет уменьшаться с течением времени, как браузеры
конкретизируют свои реализации тех спецификаций.

Момент, который следует подчеркнуть, что это мультизаполнение не фреймворки,
которые предоставляют свои собственные модели для разработки в сети, они
включают HTML5 модель. Но это на самом деле не только необходимость, есть ещё и
небольшие пробелы в платформе, где один браузер отклоняется в небольшом от
действующих стандартов, и это то, что мы должны мультизаполнить. В [MDN][14],
кажется, есть много необходимого кода, как в документации часто содержится
[короткое между функционное мультизаполнение][15].

Так одна огромная HTML5 Polyfill библиотека будет уже хорошо, но ещё лучше было
бы то, что я callhtml-5-polyfill-O-Matic, набор инструментов, который позволяет
мне писать веб-компонент через трясину стандартнов HTML+JS, а затем после
анализа моего кода, либо через статический анализ или через `Object.observe` во
время выполнения, он произведет точное подмножество полного HTML5
мультизаполнения для моего проекта.

Этот вид функциональности будет ещё более важен, чем когда я начал попытки
скрестить и соотвести веб-компоненты и библиотеки из нескольких источников, т.е.
<x-foo> от X-Tag и <core-bar> от Polymer, значит ли это, что мне придется
включают обе ети мультизаполнительные библиотеки?
([Оказывается, что ответ нет][16].) И как именно я должен получить эти
спецефические элементы? Оба X-Tag и Brick имеют спецефические пакеты генераторов:

*   [Brick Download][17]
*   [X-Tag Download][18]

Если я начну создавать собственные элементы мне нужно будет создавать и свой
собственный пакет тоже? Я не думаю, что это масштабируемая идея, я считаю, что
нам нужны идиомы и инструменты что справиться с этим гораздо лучше. Это на самом
деле может означать изменение, того как мы делаем открытый код; 'виджет' не
проект, поэтому наша работа с этими вещами должна изменится. Конечно, далее
оставлять код в Git, но вам нужен полный накладной проект на GitHub? Что-то
более легковесящее, ближе к Gist, чем текущий проект может быть лучше. Как
свести к минимуму [извержение] [19] всего этого кода в нужной форме для
использования в моем проекте?
Что-то вроде [Asset Graph][20] может быть хорошим началом для этого.

И так, что нам теперь нужно?

1. Идиомы и принципы построения переизпользованих компонентов.
2. Инструменты, которые работают в этих идиомах для компиляции, крушения, и т.д.
Все, что HTML, CSS, и JS.
3. Масштабируемое HTML5 мультизаполнение, полностью или уменьшено на основе
того, что реально используется.

Это то, что мы должны построить в будущем, в котором мы не нуждаемся, в знании
знать последнею модель новейшого фреймворка, вместо этого мы просто работаем
напрямую с платформой, потянув в спецефических элементах и библиотеках для
заполнения конкретных потребностей, и тратить наше время создавая приложение,
при этом не картографировать айсберги.

## Вопросы и ответы

**В:** Почему вы ненавидите авторов фреймворков.

**О:** Я не ненавижу их. Некоторые из моих лучших друзей авторы фрейворков. Я
допускаю немного вдохновения от языка-в-щеке от [ты погубил JavaScript][21], но
опять же, не предназначенных для авторов фреймворков.

**В:** Вы не можете сделать \__\_|\_ в HTML5, для этого вам нужен фреймворк.

**О:** Во-первых, это не вопрос. Во-вторых, спасибо что наголосили на этом.
Сейчас давайте работать вместе, чтобы добавить возможность до HTML5, что
позволяет сделать \__\_|\_ без фреймворка.

**В:** Но \___| не фреймворк, это библиотека!

**О:** Да, как я уже сказал, это градиент от gist к фреймворку, и вы
может рисовать линии немного по-другому от меня. Это нормально, это не про
классификацию какой-либо конкретной части программного обеспечения, речь идет об
отдалению от фреймворков.

**В:** Я делал это годами с помощью \_\_\_| и \\_\_\_| и \\___|.

**О:** Опять же, это не вопрос, но несмотря на это, хорошо для вас, вы должны
быть в хорошей форме, чтобы помочь всем остальным.

**В:** Таким образом, каждый должен переписать выпадающие меню, вкладки,
ползунки и переключатели сам?

**О:** Абсолютно нет, дело в том, что должен быть способ, чтобы создать те
элементы таким образом, что не требует покупки в одного конкретного фреймворка.

**В:** Чувак, все эти HTML импорты собираются убить производительность моих
сайтов.

**О:** Да, если вы реализовали все эти вещи наивно, почему я
[указывал на необходимости инструментов][22], чтобы скомпилировать и снести
весь HTML, CSS, и JS.

**В:** Так что я не должен использовать *любые* библиотеки?

**О:** Нет, это не то, что я сказал, я был очень осторожен, чтобы очертить линию
между библиотеками и фреймворками, библиотека, обеспечивающая ортогональный
кусок функциональности, которая может быть использована с другими библиотеками.
Библиотеки это хорошо, это фреймворки, которые требуют 100% покупки, которую я
хотел бы отвести от нас.

**В:** Но мне нравится привязки данных!

**О:** Много кто это делает, я только высказываю личные предпочтения. Я не
говорю, что *вы* не должны использовать связывание данных, но только то, что вам
не нужно, принимать весь фреймворк, чтобы получить привязку данных, есть
автономные библиотеки для этого.

2014-05-09

 [1]: http://platform.html5.org/
 [2]: http://w3c.github.io/webcomponents/spec/imports/
 [3]: http://wiki.ecmascript.org/doku.php?id=harmony:observe
 [4]: http://www.html5rocks.com/en/tutorials/es6/promises/
 [5]: http://www.w3.org/TR/html5/scripting-1.html#the-template-element
 [6]: http://www.joelonsoftware.com/articles/LeakyAbstractions.html
 [7]: http://codemirror.net/
 [8]: http://www.w3.org/TR/components-intro/
 [9]: http://www.html5rocks.com/en/tutorials/webcomponents/imports/
 [10]: http://www.polymer-project.org/
 [11]: http://www.x-tags.org/
 [12]: http://bosonic.github.io/
 [13]: http://mozbrick.github.io/docs/brick-flipbox.html
 [14]: https://developer.mozilla.org
 [15]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Compatibility
 [16]: http://www.polymer-project.org/articles/polymer-xtag-vanilla.html
 [17]: http://mozilla.github.io/brick/download.html
 [18]: http://www.x-tags.org/download
 [19]: https://github.com/Polymer/vulcanize
 [20]: https://github.com/assetgraph/assetgraph-builder
 [21]: http://codeofrob.com/entries/you-have-ruined-javascript.html
 [22]: http://bitworking.org/news/2014/05/zero_framework_manifesto#tools2
